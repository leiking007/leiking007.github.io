---
title: "常用脚本和配置"
date: 2025-04-26
lastmod: 2025-04-26
draft: false
tags: ['服务器']
categories: ["笔记"]
author: "lei"
summary: "包含笔记自动更新部署脚本（如 autorun.sh 等）、Python 和 Java 程序启动脚本，以及开机自启配置和 Windows 启动脚本，用于自动化部署与运行管理。"
---

# 常用脚本和配置

## 笔记自动更新部署

### autorun

`autorun.sh`

```shell
#!/bin/bash

# 设置环境变量
export PATH=/opt/mime/soft/hugo_extended_0.139.2:/opt/mime/soft/nginx/sbin:$PATH
export NVM_DIR="/opt/mime/soft/nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# 检测网络环境，无外网睡眠3秒继续执行
while !(ping -c 4 8.8.8.8 &> /dev/null;) do
    echo "网络连接失败，等待3秒下次检测"
    sleep 3
done

echo "网络连接正常。"

# 启动nginx
nginx

# ddns
nohup /opt/mime/py/venv/bin/python -u /opt/mime/py/t_ddns.py > /opt/mime/py/log/t_ddns.log 2>&1 &
# 自动检测note git仓库，并更新和构建
nohup sh /opt/mime/script/autoUpdateNote.sh > /opt/mime/py/log/autoUpdateNote.log 2>&1 &
```

### autoUpdateNote

`autoUpdateNote.sh`

```shell
#!/bin/sh

# 项目目录
path="/opt/mime/git/note_hugo"

# 定时更新git项目、并打印结果
pull_git() {
    echo "$(date +"%Y-%m-%d %H:%M:%S"): 开始更新程序"

    # 更新git库
    res=$(git -C "$path" pull 2>&1)

    echo "当前操作系统: $(uname)"
    echo "更新结果: $res"  # 标准输出



    # 更新程序
    case "$res" in
        *"Already up to date"*)
            echo "Already up to date."
            ;;
        *"Updating"*)
            cd "$path/themes/hugo-tl" || { echo "无法切换到目录: $path/themes/hugo-tl"; exit 1; }
            res=$(yarn install  2>&1)
            echo "yarn install result: $res"
            res=$(yarn run build 2>&1)
            echo "yarn run build result: $res"
            ;;
        *)
            echo "update failed."
            ;;
    esac
}

# 开始执行程序，每隔30秒执行一次
while true; do
    pull_git
    echo "$(date +"%Y-%m-%d %H:%M:%S"): 更新程序结束, 休眠中..."
    sleep 30

```

### t_ddns

`t_ddns.py`

```python
import json
import time
import socket
from tencentcloud.common import credential
from tencentcloud.common.profile.client_profile import ClientProfile
from tencentcloud.common.profile.http_profile import HttpProfile
from tencentcloud.common.exception.tencent_cloud_sdk_exception import (
    TencentCloudSDKException,
)
from tencentcloud.dnspod.v20210323 import dnspod_client, models

# 安装依赖 pip install -i https://mirrors.tencent.com/pypi/simple/ --upgrade tencentcloud-sdk-python


# 获取本地 IPv6 地址
def get_local_ipv6():
    try:
        s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        s.connect(
            ("2001:4860:4860::8888", 80)
        )  # 使用一个公共的IPv6地址（这里是谷歌的DNS服务器IPv6地址）
        local_ipv6 = s.getsockname()[0]
        s.close()
        return local_ipv6
    except Exception as e:
        print(f"获取本机IPv6地址时出错: {e}")
        return None


# 更新 IPv6 地址到 DNSPod
def update_dns_ipv6(cred, dictInfo):
    try:
        # 实例化一个http选项，可选的，没有特殊需求可以跳过
        httpProfile = HttpProfile()
        httpProfile.endpoint = "dnspod.tencentcloudapi.com"

        # 实例化一个client选项，可选的，没有特殊需求可以跳过
        clientProfile = ClientProfile()
        clientProfile.httpProfile = httpProfile
        # 实例化要请求产品的client对象,clientProfile是可选的
        client = dnspod_client.DnspodClient(cred, "", clientProfile)

        # 实例化一个请求对象,每个接口都会对应一个request对象
        req = models.ModifyRecordRequest()
        params = {
            "Domain": dictInfo.get("Domain"),
            "RecordType": dictInfo.get("RecordType", "AAAA"),
            "RecordLine": dictInfo.get("RecordLine", "默认"),
            "Value": dictInfo.get("Value"),
            "RecordId": dictInfo.get("RecordId"),
            "SubDomain": dictInfo.get("SubDomain"),
        }
        req.from_json_string(json.dumps(params))

        # 返回的resp是一个ModifyRecordResponse的实例，与请求对象对应
        resp = client.ModifyRecord(req)
        # 输出json格式的字符串回包
        print(resp.to_json_string())
    except TencentCloudSDKException as err:
        print(err)


# 获取远端现有记录，域名、子域名名称
def get_one_record(cred, dictInfo):
    try:
        # 实例化一个http选项，可选的，没有特殊需求可以跳过
        httpProfile = HttpProfile()
        httpProfile.endpoint = "dnspod.tencentcloudapi.com"

        # 实例化一个client选项，可选的，没有特殊需求可以跳过
        clientProfile = ClientProfile()
        clientProfile.httpProfile = httpProfile
        # 实例化要请求产品的client对象,clientProfile是可选的
        client = dnspod_client.DnspodClient(cred, "", clientProfile)

        # 实例化一个请求对象,每个接口都会对应一个request对象
        req = models.DescribeRecordListRequest()
        params = {"Domain": dictInfo.get("Domain")}
        req.from_json_string(json.dumps(params))
        # 返回的resp是一个DescribeRecordListResponse的实例，与请求对象对应
        resp = client.DescribeRecordList(req)
        for record in resp.RecordList:
            if record.Name == dictInfo.get("SubDomain", "-----"):
                return record
        # 输出json格式的字符串回包
        return None
    except TencentCloudSDKException as err:
        print(err)


if __name__ == "__main__":

    domain = "leilife.site"
    subDomain = "note"

    secretId = "AKIDtiOvTt9IJ7i4GExX9eIh3DAsNuPr8FML"
    secretKey = "ylPq9JMtQsKoJguztruupY3Wt5MXbWTK"
    # 实例化一个认证对象，入参需要传入腾讯云账户 SecretId 和 SecretKey，此处还需注意密钥对的保密
    cred = credential.Credential(secretId, secretKey)
    print(
        time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time())),
        ": 开始执行ddns",
    )
    # 单挑解析记录
    record = get_one_record(cred, {"Domain": domain, "SubDomain": subDomain})

    while True:
        # 获取dns记录解析的ip地址
        remoteIp = record.Value
        # 获取本地ip地址
        localIp = get_local_ipv6()
        print("本地ip地址: ", localIp)
        print("dns记录解析ip地址: ", remoteIp)
        if remoteIp != localIp and localIp is not None:
            print("ip地址不一致,需要更新")
            update_dns_ipv6(
                cred, {"Domain": domain, "SubDomain": subDomain, "Value": localIp,"RecordId":record.RecordId}
            )
        elif localIp is None:
            print("本地ip地址获取失败,稍后重试")
        else:
            print("ip地址一致,不需要更新")

        print(
            time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time())),
            ": 更新ddns结束, 休眠中...\n\n",
        )
        time.sleep(60 * 30)  # 每隔30分钟执行一次
```

### 开机自启

/etc/systemd/system/ 目录下新建服务 `myscript.service`

```
[Unit]
Description=My Startup Script
After=network.target

[Service]
Type=forking
ExecStart=/opt/mime/script/autorun.sh

[Install]
WantedBy=multi-user.target
```

```bash
# 开机自启服务
systemctl enable myscript

# 关闭开机自启
systemctl disable myscript

# 启动服务
systemctl start myscript

# 关闭服务
systemctl stop myscript

# 查看服务状态
systemctl status myscript.service
```

### winStartNote

`startNote.bat`

```bat
@echo off
SET targetDir=F:\study\git\note_hugo
cd /d %targetDir%
git pull
SET targetDir=F:\study\git\note_hugo\themes\hugo-tl
cd /d %targetDir%
npm run dev
pause
```

## sh脚本

### python程序启动脚本

```bash
#!/bin/bash
#--------------------------------------------------------
# Author               :tanglei
# Description          :java程序启动脚本
#--------------------------------------------------------

# 脚本所在目录，$0为脚本文件路径，dirname提取目录部分
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
LOG_DIR="$SCRIPT_DIR/log"  # 日志目录
APP_LOG="$LOG_DIR/app.log"  # 应用日志
OPERATE_LOG="$LOG_DIR/operate.log"  # 操作日志

cd "$SCRIPT_DIR"

if [ ! -d "$LOG_DIR" ]; then
    mkdir -p "$LOG_DIR"
fi

# -------------- 环境变量 ------------------
export PATH=$PATH:"$SCRIPT_DIR/.runtime/bin"
# -----------------------------------------

# -------------- 配置 ------------------
PIDFILE=".pid"                      # PID文件
APP_FILE="main.py"                  # 脚本名
# --------------------------------

start() {
    if [[ -f "$PIDFILE" ]]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID"; then
            echo "$APP_FILE程序已在运行，PID=$PID" | tee -a "$OPERATE_LOG"
            return 1
        fi
        echo "删除旧的PID文件 $PIDFILE" | tee -a "$OPERATE_LOG"
        rm -f "$PIDFILE"
    fi
    echo "正在启动 $APP_FILE ..." | tee -a "$OPERATE_LOG"

    nohup python $APP_FILE > "$APP_LOG" 2>&1 &
    echo $! > "$PIDFILE"
    
    # 等待三秒，判断是否启动成功
    sleep 3
    if [[ -f "$PIDFILE" ]]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID"; then
            echo "$APP_FILE程序启动成功，PID=$PID" | tee -a "$OPERATE_LOG"
            return 0
        fi
    fi
    echo "$APP_FILE程序启动失败" | tee -a "$OPERATE_LOG"
    return 1

}

clear_log() {
    echo "正在清除日志..." | tee -a "$OPERATE_LOG"
    > "$APP_LOG"
    echo "日志清除完成" | tee -a "$OPERATE_LOG"
}

stop() {
    if [[ ! -f "$PIDFILE" ]]; then
        echo "找不到 pidfile，程序可能未启动" | tee -a "$OPERATE_LOG_FILE"
        return 1
    fi
    PID=$(cat "$PIDFILE")
    if kill -0 "$PID" 2>/dev/null; then
        echo "正在停止 $APP_FILE ..." | tee -a "$OPERATE_LOG"
        kill -9 "$PID"
        while kill -0 "$PID" 2>/dev/null; do
            sleep 1
        done
        rm -f "$PIDFILE"
        echo "$APP_FILE程序停止成功，PID=$PID" | tee -a "$OPERATE_LOG"
        return 0
    else
        echo "PID=$PID 不存在，可能已停止" | tee -a "$OPERATE_LOG"
        return 1
    fi
}

tail_log() {
    echo "查看 $APP_FILE 日志..." | tee -a "$OPERATE_LOG"
    tail -500f "$APP_LOG"
    return 0
}

status() {
    if [[ -f "$PIDFILE" ]]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$APP_FILE程序正在运行，PID=$PID" | tee -a "$OPERATE_LOG"
        else
            echo "进程 $PID 已退出，但 pidfile 仍存在" | tee -a "$OPERATE_LOG"
        fi
    else
        echo "$APP_FILE程序未运行" | tee -a "$OPERATE_LOG"
    fi
    return 0
}

main() {
    echo "------------------------------------------------" | tee -a "$OPERATE_LOG"
    echo "Script executed at: $(date)" | tee -a "$OPERATE_LOG"
    echo "------------------------------------------------"
    echo "1. start server"
    echo "2. stop server"
    echo "3. status"
    echo "4. tail log"
    echo "5. clear log"
    echo "------------------------------------------------"
    read -p "please choose: " choice
    case $choice in
        1) start ;;
        2) stop ;;
        3) status ;;
        4) tail_log ;;
        5) clear_log ;;
        *) exit 0 ;;
    esac
}
main
```

### java程序启动脚本

```bash
#!/bin/bash
#--------------------------------------------------------
# Author               :tanglei
# Description          :java程序启动脚本
#--------------------------------------------------------

# 脚本所在目录，$0为脚本文件路径，dirname提取目录部分
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
LOG_DIR="$SCRIPT_DIR/log"  # 日志目录
APP_LOG="$LOG_DIR/app.log"  # 应用日志
OPERATE_LOG="$LOG_DIR/operate.log"  # 操作日志

cd "$SCRIPT_DIR"

if [ ! -d "$LOG_DIR" ]; then
    mkdir -p "$LOG_DIR"
fi

# -------------- 环境变量 ------------------
# export PATH=$PATH:/data/enviroment/jdk1.8.0_461/bin
# -----------------------------------------

# -------------- 配置 ------------------
PIDFILE=".pid"                      # PID文件
APP_FILE="app.jar"                  # 应用jar包
JAVA_OPTS="-Xms256m -Xmx512m"       # JVM参数
JAR_OPTS="--server.port=8000"       # 应用参数
# --------------------------------

start() {
    if [[ -f "$PIDFILE" ]]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID"; then
            echo "$APP_FILE程序已在运行，PID=$PID" | tee -a "$OPERATE_LOG"
            return 1
        fi
        echo "删除旧的PID文件 $PIDFILE" | tee -a "$OPERATE_LOG"
        rm -f "$PIDFILE"
    fi
    echo "正在启动 $JAR_FILE ..." | tee -a "$OPERATE_LOG"

    nohup java $JAVA_OPTS -jar $APP_FILE $JAR_OPTS > "$APP_LOG" 2>&1 &
    echo $! > "$PIDFILE"
    
    # 等待三秒，判断是否启动成功
    sleep 3
    if [[ -f "$PIDFILE" ]]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID"; then
            echo "$APP_FILE程序启动成功，PID=$PID" | tee -a "$OPERATE_LOG"
            return 0
        fi
    fi
    echo "$APP_FILE程序启动失败" | tee -a "$OPERATE_LOG"
    return 1

}

clear_log() {
    echo "正在清除日志..." | tee -a "$OPERATE_LOG"
    > "$APP_LOG"
    echo "日志清除完成" | tee -a "$OPERATE_LOG"
}

stop() {
    if [[ ! -f "$PIDFILE" ]]; then
        echo "找不到 pidfile，程序可能未启动" | tee -a "$OPERATE_LOG_FILE"
        return 1
    fi
    PID=$(cat "$PIDFILE")
    if kill -0 "$PID" 2>/dev/null; then
        echo "正在停止 $APP_FILE ..." | tee -a "$OPERATE_LOG"
        kill -9 "$PID"
        while kill -0 "$PID" 2>/dev/null; do
            sleep 1
        done
        rm -f "$PIDFILE"
        echo "$APP_FILE程序停止成功，PID=$PID" | tee -a "$OPERATE_LOG"
        return 0
    else
        echo "PID=$PID 不存在，可能已停止" | tee -a "$OPERATE_LOG"
        return 1
    fi
}

tail_log() {
    echo "查看 $APP_FILE 日志..." | tee -a "$OPERATE_LOG"
    tail -500f "$APP_LOG"
    return 0
}

status() {
    if [[ -f "$PIDFILE" ]]; then
        PID=$(cat "$PIDFILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "$APP_FILE程序正在运行，PID=$PID" | tee -a "$OPERATE_LOG"
        else
            echo "进程 $PID 已退出，但 pidfile 仍存在" | tee -a "$OPERATE_LOG"
        fi
    else
        echo "$APP_FILE程序未运行" | tee -a "$OPERATE_LOG"
    fi
    return 0
}

main() {
    echo "------------------------------------------------" | tee -a "$OPERATE_LOG"
    echo "Script executed at: $(date)" | tee -a "$OPERATE_LOG"
    echo "------------------------------------------------"
    echo "1. start server"
    echo "2. stop server"
    echo "3. status"
    echo "4. tail log"
    echo "5. clear log"
    echo "------------------------------------------------"
    read -p "please choose: " choice
    case $choice in
        1) start ;;
        2) stop ;;
        3) status ;;
        4) tail_log ;;
        5) clear_log ;;
        *) exit 0 ;;
    esac
}
main
```

